# Java基础

Java IO/NIO、并发、虚拟机、分布式、安全、性能

## 基础

### 对 Java平台的理解

- JRE 与 JDK
  - `jre`  Java运行环境，包含了 `jvm` 和 `Java` 类库，以及一些模块
  - `jdk` 可以看作是 `jre` 的一个超集，提供了更多工具，比如编译器、各种诊断工具等
- `Java` 语言特性，包括面向对象、反射、泛型、lambda、
- `Java` 基础类库，包括集合、IO/NIO、网络、并发、安全、以及海量的第三方类库：guava
- `jvm` 类加载机制，垃圾收集器、运行时、动态编译
- `jdk` 的工具，如编译器、运行时环境、安全工具、诊断和监控工具等
- 生态环境，例如JavaEE、Spring、Hadoop、spark、maven

### Java 跨平台-一次编译，到处执行

> ​	通常认为 `Java` 分为编译期和运行时，`javac` 的编译，编译 Java 源码生成 `.class` 字节码，jvm 通过加载字节码进行解释执行，这种跨平台的抽象，屏蔽了操作系统和硬件的细节。
>
> ​	在运行时，`jvm` 通过类加载器（Class-Loader）加载字节码，解释或者编译执行。

### 对比 Exception 和 Error 

> 都继承自 `Throwable`

> Exception 是程序正常运行中可预料到的意外情况，可能应该被捕获，进行相应的处理。
>
> - 检查异常
>   - checked 在源代码里必须显示的进行捕获，这是编译检查的一部分。
> - 不检查异常
>   - unchecked 即运行时异常，类似于 NullPointerException 之类，通常可以通过编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。

> Error 是指在正常情况下不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 `jvm` 自身）处于非正常状态、不可恢复状态。

#### NoClassDefFoundError 和 ClassNotFoundException 有什么区别

> NoClassDefFoundError 是一个错误(Error)，而 ClassNOtFoundException 是一个异常，在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。

> 产生原因：
>
> - Java 支持使用反射方式在运行时动态加载类，例如使用 `Class.forName` 方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到 JVM 内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出 `ClassNotFoundException` 异常。
>   - 解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。
> - 如果 JVM 或者 ClassLoader 实例尝试加载（可以通过正常的方法调用，也可能是使用 new 来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了，这个时候就会导致 `NoClassDefFoundError` 。
>   - 造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。
>   - 解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。

### final、finally、 finalize

> final 可以用来修饰类、方法、变量，分别有不同的意义：
>
> - final 修饰的 class 代表不可以继承扩展
> - final 的变量是不可以修改的
> - final 的方法也是不可以重写的（override）。

> finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-fnally 或者 try-catch-fnally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。

> finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。实践中，因为 finalize 拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致 `OOM` 的原因。

推荐使用fnal关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：

- 我们可以将方法或者类声明为 final，这样就可以明确告知别人，这些行为是不许修改的。某种程度上，这是保证平台安全的必要手段。
- 使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误。
- final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。

#### 扩展 — 如何实现 immutable 类？

- 将class自身声明为 final，这样别人就不能扩展来绕过限制了。
- 将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。
- 通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。
- 如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write 原则，创建私有的 copy。

### 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。

> 不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。
>
> - 强引用（"Strong" Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。
> - 软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 `OutOfMemoryError` 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。通过 SoftReference 类实现。
> - 弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。通过 WeakReference 类实现。
> - 对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。也有人利用幻象引用监控对象的创建和销毁。通过PhantomReference类来实现。

### Java反射机制，动态代理是基于什么原理？

> 反射机制是Java语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。

> 动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）。
