# MQ

## 为什么使用 MQ

MQ 作用

> - 消峰 （主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题）
> - 解藕（解决不同重要程度、不同能力级别系统之间依赖导致一死全死）
> - 异步（当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统）
> - 蓄流压测（线上有些链路不好压测，可以通过堆积一定量消息再放开来压测）

## 生产环境用的什么消息中间件？

RocketMQ

优势：

> - 支持事务型消息（消息发送和DB操作保持两方的最终一致性，rabbitmq和kafka不支持）
> - 支持结合rocketmq的多个系统之间数据最终一致性（多方事务，二方事务是前提）
> -  支持18个级别的延迟消息（rabbitmq和kafka不支持）
> - 支持指定次数和时间间隔的失败消息重发（kafka不支持，rabbitmq需要手动确认）
> - 支持consumer端tag过滤，减少不必要的网络传输（rabbitmq和kafka不支持）
> - 支持重复消费（rabbitmq不支持，kafka支持）

选型的时候考虑的点

- 使用场景
- 社区活跃度
- API 完善程度已经源码可读性
- 独立部署也可以使用云
- 高可靠、高性能、多协议
- 持久化

## 使用MQ后存在缺陷

1. 系统可用可行性降低
   - mq 一旦故障，整个系统不能运转了
2. 系统复杂性变高
   - 消息重复 - 插入了两个同样的数据
   - 丢失
   - 顺序变了
3. 一致性问题
   - 多个消费系统，其中一个失败，给用户返回成功，其实还存在问题

## 如何保证MQ的高可用

